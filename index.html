<!DOCTYPE html>
<!--
// Global pixel field automaton v0.1.4
// 
// CHANGES:
// * Normalization of random noise for step by step visualization
// * Attempt at improving UI (placed continous simulation controls under field)
//
// FEATURES:
// * Drawing/Erasing
// * Two fields
// * Independent field temperatures
// * Independent cross field interactions
// * Step by step simulation for educational puppores and bug fixing
// * Continuous simulation
// * Seperable and iterative Gaussian blurring
// * Pixel perfect rendering
// * Custom field size
-->

<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Two-Field Pixel Particle Simulation</title>
    <style>
        body { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            font-family: Arial, sans-serif;
            margin: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .main-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            width: 100%;
            padding: 20px;
        }
        
        .left-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .canvas-container {
            flex: 0 0 auto;
        }
        
        .simulation-controls {
            width: 100%;
            max-width: 400px; /* Match canvas width */
        }
        
        .controls-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 500px;
        }
        
        canvas { 
            border: 1px solid black;
        }
        
        .control-group {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .control-row label {
            min-width: 120px;
            font-size: 0.9rem;
        }
        
        .control-row input[type="range"] {
            flex: 1;
        }
        
        .control-row span {
            min-width: 40px;
            text-align: right;
        }
        
        .button-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        input[type="number"] {
            width: 80px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .step-count {
            font-size: 0.9rem;
            color: #666;
            margin-left: 10px;
        }

        .field-selector {
            display: flex;
            gap: 10px;
        }

        .field-button {
            flex: 1;
            padding: 8px;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .field-button.field1 {
            background: rgba(0, 0, 255, 0.2);
        }

        .field-button.field2 {
            background: rgba(255, 0, 0, 0.2);
        }

        .field-button.selected {
            border-color: #007bff;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
        }
    </style>
</head>
<body>
    <h2>Two-Field Pixel Particle Simulation</h2>
	
    <div class="main-container">
        <div class="left-section">
            <div class="canvas-container">
                <canvas id="particleCanvas" width="900" height="900"></canvas>
            </div>
            
            <div class="simulation-controls control-group">
                <h3>Continuous Simulation</h3>
                <div class="control-row">
                    <label>Steps:</label>
                    <input type="number" id="simulationSteps" min="1" max="10000" value="100000">
                    <span class="step-count">Current: <span id="currentStepDisplay">0</span></span>
                </div>
                <div class="button-group">
                    <button id="startSimulationButton">Start Simulation</button>
                    <button id="stopSimulationButton" disabled>Stop Simulation</button>
                </div>
            </div>
        </div>

        <div class="controls-container">
            <div class="control-group">
                <h3>Field Selection</h3>
                <div class="field-selector">
                    <button class="field-button field1 selected" id="field1Button">Field 1 (Blue)</button>
                    <button class="field-button field2" id="field2Button">Field 2 (Red)</button>
                </div>
            </div>

            <div class="control-group">
                <h3>Drawing Controls</h3>
                <div class="control-row">
                    <label>Brush Size:</label>
                    <input type="range" id="brushSize" min="1" max="50" value="10">
                    <span id="brushSizeDisplay">10</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Simulation Parameters</h3>
                <div class="control-row">
                    <label>Sigma:</label>
                    <input type="range" id="sigmaSetting" min="0.1" max="10" step="0.1" value="1.5">
                    <span id="sigmaDisplay">1.5</span>
                </div>
                <div class="control-row">
                    <label>Temperature:</label>
                    <input type="range" id="temperatureSetting" min="0" max="5" step="0.02" value="0.50">
                    <span id="temperatureDisplay">0.5</span>
                </div>                
                <div class="control-row">
                    <label>Field 1 Self-interaction:</label>
                    <input type="range" id="attraction1Setting" min="0.02" max="5" step="0.02" value="1.00">
                    <span id="attraction1Display">1.00</span>
                </div>
                <div class="control-row">
                    <label>Field 2 Self-interaction:</label>
                    <input type="range" id="attraction2Setting" min="0.02" max="5" step="0.02" value="1.0">
                    <span id="attraction2Display">1.00</span>
                </div>
                <div class="control-row">
                    <label>Interaction with Field 1:</label>
                    <input type="range" id="interaction1Setting" min="0" max="5.0" step="0.02" value="0.00">
                    <span id="interaction1Display">0.00</span>
                </div>
				<div class="control-row">
                    <label>Interaction with Field 2:</label>
                    <input type="range" id="interaction2Setting" min="0" max="5.0" step="0.02" value="0.00">
                    <span id="interaction2Display">0.00</span>
                </div>
                <div class="control-row">
                    <label>Gravity:</label>
                    <input type="range" id="gravitySetting" min="0" max="0.5" step="0.01" value="0">
                    <span id="gravityDisplay">0.00</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Step Controls</h3>
                <div class="button-group">
                    <button id="blurButton">1. Apply Blur</button>
					<button id="crossFieldButton">2. Cross Field Interactions</button>
                    <button id="rollDiceButton">3. Roll Dice</button>
                    <button id="discretizeButton">4. Discretize</button>
                    <button id="fullStepButton">Complete Step</button>
                </div>
            </div>
        </div>
    </div>

    <script>
		class GridBorderCalculator {
			constructor(gridSizeX, gridSizeY) {
				this.gridSizeX = gridSizeX;
				this.gridSizeY = gridSizeY;
			}

			getBorderIndices() {
				const indices = [];
				
				// Top row
				for (let x = 0; x < this.gridSizeX; x++) {
					indices.push(x);
				}
				
				// Bottom row
				let bottomRowStart = this.gridSizeX * (this.gridSizeY - 1);
				for (let x = 0; x < this.gridSizeX; x++) {
					indices.push(bottomRowStart + x);
				}
				
				// Left and right edges (excluding corners)
				for (let y = 1; y < this.gridSizeY - 1; y++) {
					// Left edge
					indices.push(y * this.gridSizeX);
					// Right edge
					indices.push(y * this.gridSizeX + this.gridSizeX - 1);
				}
				
				return indices;
			}
		}
        
    class PerformanceMonitor {
        constructor() {
            this.metrics = {
                borders: [],
                blur: [],
      crossfield: [],
                dice: [],
                discretize: [],
                render: []
            };
            this.sampleCount = 0;
            this.maxSamples = 100;
        }
    
        addMetric(component, time) {
            this.metrics[component].push(time);
            if (this.metrics[component].length > this.maxSamples) {
                this.metrics[component].shift();
            }
        }
    
        getAverages() {
            const averages = {};
            let total = 0;
    
            for (const [component, times] of Object.entries(this.metrics)) {
                if (times.length === 0) continue;
                const avg = times.reduce((a, b) => a + b, 0) / times.length;
                averages[component] = avg;
                total += avg;
            }
    
            const normalized = {};
            for (const [component, avg] of Object.entries(averages)) {
                normalized[component] = (avg / total * 100).toFixed(1);
            }
    
            return {
                raw: averages,
                normalized,
                total: total.toFixed(2)
            };
        }
    
        logPerformance() {
            const stats = this.getAverages();
            console.log('\n=== Performance Breakdown ===');
            console.log(`Total time per step: ${stats.total}ms`);
            console.log('Component breakdown:');
            Object.entries(stats.normalized).forEach(([component, percentage]) => {
                const bar = '█'.repeat(Math.round(percentage / 2));
                console.log(`${component.padEnd(10)}: ${percentage}% ${bar}`);
            });
            console.log('=========================\n');
        }
    }

		class PixelSimulation {
			constructor(canvasId, initialGridSizeX = 150, initialGridSizeY = 150) {
				this.canvas = document.getElementById(canvasId);
				this.ctx = this.canvas.getContext('2d');
				this.gridSizeX = initialGridSizeX;
				this.gridSizeY = initialGridSizeY;
				this.updateCanvasSize();
				
				// Initialize grids with correct dimensions
				this.initializeGrids();
				
				// Create border calculator with correct dimensions
				this.GridBorderCalculator = new GridBorderCalculator(this.gridSizeX, this.gridSizeY);
				this.borderIndices = this.GridBorderCalculator.getBorderIndices();
				
				this.usePBC = false;
						
				this.GridBorderCalculator = new GridBorderCalculator(this.gridSizeX, this.gridSizeY);
				this.borderIndices = this.GridBorderCalculator.getBorderIndices();
				
				// Rest of the constructor remains the same
				this.attraction1 = 1.0;
				this.attraction2 = 1.0;
				this.interaction1Strength = 0.0;
				this.interaction2Strength = 0.0;
				this.gravity = 0.0;
				this.npixels1 = 0.0;
				this.npixels2 = 0.0;
        this.temperature = 0.5;
				
				this.borderPixels1 = new Set();
				this.borderPixels2 = new Set();
				
				this.boundaryGrid1 = new Float32Array(this.gridSizeX * this.gridSizeY);
				this.boundaryGrid2 = new Float32Array(this.gridSizeX * this.gridSizeY);             
				
				this.brushSize = 10;
				this.isDrawing = false;
				this.drawMode = null;
				this.activeField = 1;
        this.lockField1 = false; // Lock for blue field
        this.lockField2 = false; // Lock for red field
				
				this.sigma = 1.5;
				this.kernelSize = 5;
				this.iterations = 2;
				this.gaussianKernel1D = this.createGaussianKernel1D();
				this.tempGrid = new Float32Array(this.gridSizeX * this.gridSizeY);
				
				this.simulationTimer = null;
				this.currentStep = 0;
				this.totalSimulationSteps = 100000;
				
				this.setupEventListeners();
				this.setupControls();
				this.updateBorderPixels();
				
				this.performance = new PerformanceMonitor();
			}
			
			initializeGrids() {
				const size = this.gridSizeX * this.gridSizeY;
				this.grid1 = new Float32Array(size);
				this.grid2 = new Float32Array(size);
				this.blurredGrid1 = new Float32Array(size);
				this.blurredGrid2 = new Float32Array(size);
				this.boundaryGrid1 = new Float32Array(size);
				this.boundaryGrid2 = new Float32Array(size);
				this.tempGrid = new Float32Array(size);
			}	

			updateCanvasSize() {
				// Calculate cell sizes to maintain aspect ratio
				const maxWidth = 900;  // Maximum canvas width
				const maxHeight = 900; // Maximum canvas height
				
				// Calculate the cell size that will fit within max dimensions
				const cellSizeX = Math.floor(maxWidth / this.gridSizeX);
				const cellSizeY = Math.floor(maxHeight / this.gridSizeY);
				
				// Use the smaller cell size to ensure square cells
				this.cellSize = Math.min(cellSizeX, cellSizeY);
				
				// Update canvas dimensions
				this.canvas.width = this.gridSizeX * this.cellSize;
				this.canvas.height = this.gridSizeY * this.cellSize;
				
				// Clear any existing offscreen canvas
				this.offscreenCanvas = null;
			}			
      
      setupFieldLockControls() {
          const controlGroup = document.createElement('div');
          controlGroup.className = 'control-group';
          controlGroup.innerHTML = `
              <h3>Field Locking</h3>
              <div class="control-row">
                  <label>Lock Field 1 (Blue):</label>
                  <input type="checkbox" id="lockField1Toggle">
              </div>
              <div class="control-row">
                  <label>Lock Field 2 (Red):</label>
                  <input type="checkbox" id="lockField2Toggle">
              </div>
          `;

          // Insert after the field selection controls
          const fieldSelectionGroup = document.getElementById('field1Button').closest('.control-group');
          fieldSelectionGroup.parentNode.insertBefore(controlGroup, fieldSelectionGroup.nextSibling);

          // Add event listeners
          document.getElementById('lockField1Toggle').addEventListener('change', (e) => {
              this.lockField1 = e.target.checked;
              this.updateBorderPixels(); // Update border pixels when lock status changes
          });

          document.getElementById('lockField2Toggle').addEventListener('change', (e) => {
              this.lockField2 = e.target.checked;
              this.updateBorderPixels(); // Update border pixels when lock status changes
          });
      }      
			
			setupSizeControls() {
				// Create new control group for size settings
				const controlGroup = document.createElement('div');
				controlGroup.className = 'control-group';
				controlGroup.innerHTML = `
					<h3>Grid Size Controls</h3>
					<div class="control-row">
						<label>X Size:</label>
						<input type="range" id="gridSizeX" min="50" max="300" value="${this.gridSizeX}">
						<span id="gridSizeXDisplay">${this.gridSizeX}</span>
					</div>
					<div class="control-row">
						<label>Y Size:</label>
						<input type="range" id="gridSizeY" min="50" max="300" value="${this.gridSizeY}">
						<span id="gridSizeYDisplay">${this.gridSizeY}</span>
					</div>
					<div class="control-row">
						<button id="applyGridSize">Apply Size Changes</button>
					</div>
				`;

				// Insert at the beginning of controls container
				const controlsContainer = document.querySelector('.controls-container');
				controlsContainer.insertBefore(controlGroup, controlsContainer.firstChild);

				// Add event listeners
				const xSlider = document.getElementById('gridSizeX');
				const ySlider = document.getElementById('gridSizeY');
				const xDisplay = document.getElementById('gridSizeXDisplay');
				const yDisplay = document.getElementById('gridSizeYDisplay');
				const applyButton = document.getElementById('applyGridSize');

				xSlider.addEventListener('input', () => {
					xDisplay.textContent = xSlider.value;
				});

				ySlider.addEventListener('input', () => {
					yDisplay.textContent = ySlider.value;
				});

				applyButton.addEventListener('click', () => {
					const newSizeX = parseInt(xSlider.value);
					const newSizeY = parseInt(ySlider.value);
					
					// Update grid sizes
					this.gridSizeX = newSizeX;
					this.gridSizeY = newSizeY;
					
					// Reinitialize simulation with new sizes
					this.updateCanvasSize();
					this.initializeGrids();
					this.GridBorderCalculator = new GridBorderCalculator(this.gridSizeX, this.gridSizeY);
					this.borderIndices = this.GridBorderCalculator.getBorderIndices();
					this.updateBorderPixels();
					
					// Clear the canvas and render
					this.render();
				});
			}			
			
			setupPBCControl() {
				const controlGroup = document.createElement('div');
				controlGroup.className = 'control-group';
				controlGroup.innerHTML = `
					<h3>Boundary Conditions</h3>
					<div class="control-row">
						<label>Periodic Boundary:</label>
						<input type="checkbox" id="pbcToggle">
					</div>
				`;

				// Find the blur controls and insert after them
				const kernelSizeElement = document.getElementById('kernelSize');
				if (kernelSizeElement) {
					const blurControls = kernelSizeElement.closest('.control-group');
					blurControls.parentNode.insertBefore(controlGroup, blurControls.nextSibling);
				} else {
					// Fallback: append to controls container if blur controls not found
					const controlsContainer = document.querySelector('.controls-container');
					controlsContainer.appendChild(controlGroup);
				}

				// Add event listener
				document.getElementById('pbcToggle').addEventListener('change', (e) => {
					this.usePBC = e.target.checked;
					if (this.usePBC) {
						this.borderPixels1.clear();
						this.borderPixels2.clear();
						this.boundaryGrid1.fill(0);
						this.boundaryGrid2.fill(0);
					} else {
						this.updateBorderPixels();
					}
				});
			}			
			
			setupBlurControls() {
				const controlGroup = document.createElement('div');
				controlGroup.className = 'control-group';
				controlGroup.innerHTML = `
					<h3>Blur Settings</h3>
					<div class="control-row">
						<label>Kernel Size:</label>
						<select id="kernelSize">
							<option value="3">3x3</option>
							<option value="5" selected>5x5</option>
							<option value="7">7x7</option>
							<option value="9">9x9</option>
							<option value="11">11x11</option>
							<option value="13">13x13</option>
						</select>
					</div>
					<div class="control-row">
						<label>Iterations:</label>
						<input type="range" id="iterationsSetting" min="1" max="10" value="2">
						<span id="iterationsDisplay">2</span>
					</div>
				`;

				// Insert after sigma control
				const sigmaControl = document.getElementById('sigmaSetting').closest('.control-group');
				sigmaControl.parentNode.insertBefore(controlGroup, sigmaControl.nextSibling);

				// Add event listeners
				document.getElementById('kernelSize').addEventListener('change', (e) => {
					this.kernelSize = parseInt(e.target.value);
					this.gaussianKernel1D = this.createGaussianKernel1D();
				});

				const iterationsSlider = document.getElementById('iterationsSetting');
				const iterationsDisplay = document.getElementById('iterationsDisplay');
				iterationsSlider.addEventListener('input', (e) => {
					this.iterations = parseInt(e.target.value);
					iterationsDisplay.textContent = this.iterations;
				});
			}
			
			createGaussianKernel1D() {
				const radius = Math.floor(this.kernelSize / 2);
				const kernel = new Float32Array(this.kernelSize);
				let sum = 0;
				
				// Create basic Gaussian distribution without gravity
				for (let x = -radius; x <= radius; x++) {
					const value = Math.exp(-(x * x) / (2 * this.sigma * this.sigma));
					kernel[x + radius] = value;
					sum += value;
				}
				
				// Normalize
				for (let i = 0; i < this.kernelSize; i++) {
					kernel[i] /= sum;
				}
				
				return kernel;
			}	

			applyGaussianBlur() {
				// Create local temporary grids for each field to prevent cross-contamination
				const tempGrid = new Float32Array(this.gridSizeX * this.gridSizeY);
				
				// Update kernel if sigma or gravity changed
				this.gaussianKernel1D = this.createGaussianKernel1D();
				
				// Apply independent blur to each field
				this.applySeparableBlur(this.grid1, this.blurredGrid1, this.borderPixels1, tempGrid);
				this.applySeparableBlur(this.grid2, this.blurredGrid2, this.borderPixels2, tempGrid);
        
        // Multiply with the self-interactions
        for(var i=0; i<this.blurredGrid1.length; i++) {
          this.blurredGrid1[i] *= this.attraction1;
        }
        for(var i=0; i<this.blurredGrid2.length; i++) {
          this.blurredGrid2[i] *= this.attraction2;
        }
			}

			applySeparableBlur(inputGrid, outputGrid, borderPixels, tempGrid) {
				// Fully reset temporary grid
				tempGrid.fill(0);
				
				// Initial copy of input to output
				outputGrid.set(inputGrid);
				
				// Perform blur iterations
				for (let iter = 0; iter < this.iterations; iter++) {
        // Horizontal pass
				this.horizontalPass(outputGrid, tempGrid, borderPixels);
					
				// Vertical pass
				this.verticalPass(tempGrid, outputGrid, borderPixels);
				}
			}

			horizontalPass(input, output, borderPixels) {
				const radius = Math.floor(this.kernelSize / 2);
				output.fill(0);
				
				for (let y = 0; y < this.gridSizeY; y++) {
					for (let x = 0; x < this.gridSizeX; x++) {
						const index = y * this.gridSizeX + x;
						
						if (!this.usePBC && borderPixels.has(index)) {
							output[index] = input[index];
							continue;
						}

						let sum = 0;
						let weightSum = 0;
						
						for (let i = -radius; i <= radius; i++) {
							let sourceX;
							if (this.usePBC) {
								sourceX = ((x + i) % this.gridSizeX + this.gridSizeX) % this.gridSizeX;
							} else {
								sourceX = Math.min(Math.max(x + i, 0), this.gridSizeX - 1);
							}
							
							const sourceIndex = y * this.gridSizeX + sourceX;
							const weight = this.gaussianKernel1D[i + radius];
							
							sum += input[sourceIndex] * weight;
							weightSum += weight;
						}
						
						output[index] = sum / weightSum;
					}
				}
			}

			verticalPass(input, output, borderPixels) {
				const radius = Math.floor(this.kernelSize / 2);
				
				for (let x = 0; x < this.gridSizeX; x++) {
					for (let y = 0; y < this.gridSizeY; y++) {
						const index = y * this.gridSizeX + x;
						
						if (!this.usePBC && borderPixels.has(index)) {
							output[index] = input[index];
							continue;
						}

						let sum = 0;
						let weightSum = 0;
						
						for (let i = -radius; i <= radius; i++) {
							let sourceY;
							if (this.usePBC) {
								sourceY = ((y + i) % this.gridSizeY + this.gridSizeY) % this.gridSizeY;
							} else {
								sourceY = Math.min(Math.max(y + i, 0), this.gridSizeY - 1);
							}
							
							const sourceIndex = sourceY * this.gridSizeX + x;
							let weight = this.gaussianKernel1D[i + radius];
							
							if (!this.usePBC) {
								if (i > 0) {
									weight *= Math.pow(1 - this.gravity, i);
								} else if (i < 0) {
									weight *= Math.pow(1 + this.gravity/2, Math.abs(i));
								}
							}
							
							sum += input[sourceIndex] * weight;
							weightSum += weight;
						}
						
						output[index] = sum / weightSum;
					}
				}
			}	

			setupControls() {
				// Add controls in the correct order
				this.setupSizeControls();
				this.setupFieldSelection();
				this.setupBrushSizeControl();
				this.setupBlurControls();     // Move blur controls before PBC
				this.setupPBCControl();       // PBC control comes after blur controls
				this.setupSimulationControls();
				this.setupStepControls();
        this.setupFieldLockControls();
			}
            
      setupFieldSelection() {
        const field1Button = document.getElementById('field1Button');
        const field2Button = document.getElementById('field2Button');
          
        field1Button.addEventListener('click', () => {
            this.activeField = 1;
            field1Button.classList.add('selected');
            field2Button.classList.remove('selected');
        });
          
        field2Button.addEventListener('click', () => {
            this.activeField = 2;
            field2Button.classList.add('selected');
            field1Button.classList.remove('selected');
        });
      }
			
			normalizeField(arr) {
				const max = Math.max(...arr);
				return arr.map(val => val / max);
			}
            
      setupStepControls() {
          document.getElementById('blurButton').addEventListener('click', () => {
              this.applyGaussianBlur();
              this.render();
          });
  
          document.getElementById('crossFieldButton').addEventListener('click', () => {
              this.applyCrossFieldInteractions();
              console.log('We should be seeing the cross field now.')
              this.render();
          });				
          
          document.getElementById('rollDiceButton').addEventListener('click', () => {
              this.rollDice();
              this.normalizeField(this.blurredGrid1);
              this.normalizeField(this.blurredGrid2);
              this.render();
          });
          
          document.getElementById('discretizeButton').addEventListener('click', () => {
              this.discretize();
              this.render();
          });
          
          document.getElementById('fullStepButton').addEventListener('click', () => {
              this.simulationStep();
          });
      }
      
      setupSimulationControls() {
          const sigmaSlider = document.getElementById('sigmaSetting');
          const sigmaDisplay = document.getElementById('sigmaDisplay');
          const simulationStepsInput = document.getElementById('simulationSteps');
          const startSimulationButton = document.getElementById('startSimulationButton');
          const stopSimulationButton = document.getElementById('stopSimulationButton');
          const currentStepDisplay = document.getElementById('currentStepDisplay');
          const temperatureSlider = document.getElementById('temperatureSetting');
          const temperatureDisplay = document.getElementById('temperatureDisplay');
          const attraction1Slider = document.getElementById('attraction1Setting');
          const attraction1Display = document.getElementById('attraction1Display');
          const attraction2Slider = document.getElementById('attraction2Setting');
          const attraction2Display = document.getElementById('attraction2Display');
          const interaction1Slider = document.getElementById('interaction1Setting');
          const interaction2Slider = document.getElementById('interaction2Setting');
          const interaction1Display = document.getElementById('interaction1Display');
          const interaction2Display = document.getElementById('interaction2Display');
          const gravitySlider = document.getElementById('gravitySetting');
          const gravityDisplay = document.getElementById('gravityDisplay');
          
          sigmaSlider.addEventListener('input', (e) => {
              this.sigma = parseFloat(e.target.value);
              sigmaDisplay.textContent = this.sigma.toFixed(1);
              this.gaussianKernel = this.createGaussianKernel1D(this.sigma);
          });
          
          temperatureSlider.addEventListener('input', (e) => {
              this.temperature = parseFloat(e.target.value);
              temperatureDisplay.textContent = this.temperature.toFixed(2);
          });
          
          attraction1Slider.addEventListener('input', (e) => {
              this.attraction1 = parseFloat(e.target.value);
              attraction1Display.textContent = this.attraction1.toFixed(2);
          });

          attraction2Slider.addEventListener('input', (e) => {
              this.attraction2 = parseFloat(e.target.value);
              attraction2Display.textContent = this.attraction2.toFixed(2);
          });

          interaction1Slider.addEventListener('input', (e) => {
              this.interaction1Strength = parseFloat(e.target.value);
              interaction1Display.textContent = this.interaction1Strength.toFixed(2);
          });
  
          interaction2Slider.addEventListener('input', (e) => {
              this.interaction2Strength = parseFloat(e.target.value);
              interaction2Display.textContent = this.interaction2Strength.toFixed(2);
          });

          gravitySlider.addEventListener('input', (e) => {
              this.gravity = parseFloat(e.target.value);
              gravityDisplay.textContent = this.gravity.toFixed(2);
              this.gaussianKernel = this.createGaussianKernel1D(this.sigma);
          });
          
          simulationStepsInput.addEventListener('input', (e) => {
              this.totalSimulationSteps = parseInt(e.target.value);
          });
          
          startSimulationButton.addEventListener('click', () => {
              this.startSimulation();
              this.updateSimulationButtons(true);
          });
          
          stopSimulationButton.addEventListener('click', () => {
              this.stopSimulation();
              this.updateSimulationButtons(false);
          });
      }
            
      updateSimulationButtons(isRunning) {
          document.getElementById('startSimulationButton').disabled = isRunning;
          document.getElementById('stopSimulationButton').disabled = !isRunning;
          document.getElementById('blurButton').disabled = isRunning;
          document.getElementById('crossFieldButton').disabled = isRunning;
          document.getElementById('rollDiceButton').disabled = isRunning;
          document.getElementById('discretizeButton').disabled = isRunning;
          document.getElementById('fullStepButton').disabled = isRunning;
      }
            
      startSimulation() {
          if (this.simulationTimer) return;
          
          this.simulationTimer = setInterval(() => {
              if (this.currentStep >= this.totalSimulationSteps) {
                  this.stopSimulation();
                  this.updateSimulationButtons(false);
                  return;
              }
              
              this.simulationStep();
              this.currentStep++;
              document.getElementById('currentStepDisplay').textContent = this.currentStep;
          }, 10);
      }
            
      stopSimulation() {
          if (this.simulationTimer) {
              clearInterval(this.simulationTimer);
              this.simulationTimer = null;
          }
      }
            
      simulationStep() {
          const t0 = performance.now();
          this.updateBorderPixels();
          const t1 = performance.now();
          this.performance.addMetric('borders', t1 - t0);

          const t2 = performance.now();
          this.applyGaussianBlur();
          const t3 = performance.now();
          this.performance.addMetric('blur', t3 - t2);
  
          const t8 = performance.now();
          this.render();
          const t9 = performance.now();
          this.performance.addMetric('render', t9 - t8);
  
          const t10 = performance.now();
          this.applyCrossFieldInteractions();
          const t11 = performance.now();
          this.performance.addMetric('crossfield', t11 - t10);

          const t4 = performance.now();
          this.rollDice();
          const t5 = performance.now();
          this.performance.addMetric('dice', t5 - t4);

          const t6 = performance.now();
          this.discretize();
          const t7 = performance.now();
          this.performance.addMetric('discretize', t7 - t6);



          if (this.currentStep % 100 === 0) {
              this.performance.logPerformance();
          }
      }

      setupEventListeners() {
          this.canvas.addEventListener('mousedown', this.startDrawing.bind(this));
          this.canvas.addEventListener('mousemove', this.draw.bind(this));
          this.canvas.addEventListener('mouseup', this.stopDrawing.bind(this));
          this.canvas.addEventListener('mouseout', this.stopDrawing.bind(this));
      }
            
      setupBrushSizeControl() {
          const brushSizeSlider = document.getElementById('brushSize');
          const brushSizeDisplay = document.getElementById('brushSizeDisplay');
          
          brushSizeSlider.addEventListener('input', (e) => {
              this.brushSize = parseInt(e.target.value);
              brushSizeDisplay.textContent = this.brushSize;
          });
      }

      startDrawing(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          const gridX = Math.floor(x / this.cellSize);
          const gridY = Math.floor(y / this.cellSize);
          
          const grid = this.activeField === 1 ? this.grid1 : this.grid2;
          const currentValue = this.getGridValue(gridX, gridY, grid);
          this.drawMode = currentValue > 0 ? 'remove' : 'add';
          
          this.isDrawing = true;
          this.draw(e);
      }
            
      stopDrawing() {
          this.isDrawing = false;
          this.drawMode = null;
          this.setCountPixels();
          this.updateBorderPixels();
      }
            
			draw(e) {
				if (!this.isDrawing || this.drawMode === null) return;
				
				const rect = this.canvas.getBoundingClientRect();
				const x = e.clientX - rect.left;
				const y = e.clientY - rect.top;
				
				const gridX = Math.floor(x / this.cellSize);
				const gridY = Math.floor(y / this.cellSize);
				
				const radius = this.brushSize / 2;
				let pixelsChanged = false;
				const grid = this.activeField === 1 ? this.grid1 : this.grid2;
				const boundaryGrid = this.activeField === 1 ? this.boundaryGrid1 : this.boundaryGrid2;
				
				for (let dx = -Math.ceil(radius); dx <= Math.ceil(radius); dx++) {
					for (let dy = -Math.ceil(radius); dy <= Math.ceil(radius); dy++) {
						const checkX = gridX + dx;
						const checkY = gridY + dy;
						
						if (Math.sqrt(dx*dx + dy*dy) <= radius) {
							if (checkX >= 0 && checkX < this.gridSizeX &&
								checkY >= 0 && checkY < this.gridSizeY) {
								const index = checkY * this.gridSizeX + checkX;
								const currentValue = this.getGridValue(checkX, checkY, grid);
								const newValue = this.drawMode === 'add' ? 1 : 0;
								
								if (currentValue !== newValue) {
									this.setGridValue(checkX, checkY, newValue, grid);
									if (!this.usePBC && this.borderIndices.includes(index)) {
										boundaryGrid[index] = newValue;
									}
									pixelsChanged = true;
								}
							}
						}
					}
				}
				
				if (pixelsChanged) {
					const blurredGrid = this.activeField === 1 ? this.blurredGrid1 : this.blurredGrid2;
					blurredGrid.set(grid);
					this.render();
				}
			}
			
			applyCrossFieldInteractions() {
        for (let i = 0; i < this.grid1.length; i++) {
          var rawBlurredGrid1 = this.blurredGrid1[i]
          var rawBlurredGrid2 = this.blurredGrid2[i]
                    
          if (!this.borderPixels1.has(i)) {
            // Write the interaction of 2 on 1
            if (rawBlurredGrid2 >= 0.01) {
              if (rawBlurredGrid2 <= 1.0) {
                this.blurredGrid1[i] += (0.5 - rawBlurredGrid2) * this.interaction2Strength * 2;
                //this.blurredGrid1[i] += this.blurredGrid2[i] * this.interaction2Strength;
              }
            }
                    }
                    
          if (!this.borderPixels2.has(i)) {
            // Write the interaction of 1 on 2
            if (rawBlurredGrid1 >= 0.01) {
              if (rawBlurredGrid1 <= 1.0) {
                this.blurredGrid2[i] += (0.5 - rawBlurredGrid1) * this.interaction1Strength * 2;
                //this.blurredGrid2[i] += this.blurredGrid1[i] * this.interaction1Strength;
              }
            }
            }
        }
			}
            
      rollDice() {
				// Roll the dice on the discretized grid to prepare for discretization
        this.rollDiceSingleField(this.blurredGrid1, this.borderPixels1);
        this.rollDiceSingleField(this.blurredGrid2, this.borderPixels2);
      }
      
      rollDiceSingleField(grid, borderPixels) {
        for (let i = 0; i < grid.length; i++) {
            if (!borderPixels.has(i)) {
                const randomValue = Math.random();
                grid[i] += (randomValue * this.temperature);
            }
        }
      }

			discretize() {
				// Apply the discretization in the smooth field
        if (!this.lockField1) {
          this.discretizeSingleField(this.blurredGrid1, this.npixels1, this.borderPixels1, this.boundaryGrid1);
          this.grid1.set(this.blurredGrid1); // Copy back from smoothing to discretized field
				}
        if (!this.lockField2) {
          this.discretizeSingleField(this.blurredGrid2, this.npixels2, this.borderPixels2, this.boundaryGrid2);
          this.grid2.set(this.blurredGrid2); // Copy back from smoothing to discretized field
				}
			}
            
			discretizeSingleField(grid, targetCount, borderPixels, boundaryGrid) {
				// First restore boundary pixels to their original state if not PBC
				if (!this.usePBC) {
					for (const index of this.borderIndices) {
						grid[index] = boundaryGrid[index];
					}
				}
				
				// Calculate how many non-boundary pixels we need
				const nonBorderPixelCount = targetCount - Array.from(borderPixels).reduce((sum, index) => sum + grid[index], 0);
				
				// Create arrays for sorting non-boundary pixels
				const values = [];
				const indices = [];
				
				for (let i = 0; i < grid.length; i++) {
					if (!borderPixels.has(i)) {
						values.push(grid[i]);
						indices.push(i);
					}
				}
				
				// Sort indices by their corresponding values
				indices.sort((a, b) => grid[b] - grid[a]);
				
				// Reset non-boundary pixels
				for (let i = 0; i < grid.length; i++) {
					if (!borderPixels.has(i)) {
						grid[i] = 0;
					}
				}
				
				// Set top N non-boundary pixels to 1
				for (let i = 0; i < nonBorderPixelCount && i < indices.length; i++) {
					grid[indices[i]] = 1;
				}
			}
			
      updateBorderPixels() {
          // Clear the border pixel sets
          this.borderPixels1.clear();
          this.borderPixels2.clear();
          
          // Skip border pixel updates if using PBC and no fields are locked
          if (this.usePBC && !this.lockField1 && !this.lockField2) {
              return;
          }
          
          // Add boundary pixels
          if (!this.usePBC) {
              for (const index of this.borderIndices) {
                  if (this.boundaryGrid1[index] > 0) {
                      this.borderPixels1.add(index);
                  }
                  if (this.boundaryGrid2[index] > 0) {
                      this.borderPixels2.add(index);
                  }
              }
          }
          
          // If field 1 is locked, add all non-zero pixels to the border set
          if (this.lockField1) {
              for (let i = 0; i < this.grid1.length; i++) {
                  if (this.grid1[i] > 0) {
                      this.borderPixels1.add(i);
                  }
              }
          }
          
          // If field 2 is locked, add all non-zero pixels to the border set
          if (this.lockField2) {
              for (let i = 0; i < this.grid2.length; i++) {
                  if (this.grid2[i] > 0) {
                      this.borderPixels2.add(i);
                  }
              }
          }
      }		

			getGridValue(x, y, grid) {
				return grid[y * this.gridSizeX + x];
			}
            
			setGridValue(x, y, value, grid) {
				grid[y * this.gridSizeX + x] = value;
			}
            
      setCountPixels() {
          this.npixels1 = this.grid1.reduce((count, value) => count + (value > 0 ? 1 : 0), 0);
          this.npixels2 = this.grid2.reduce((count, value) => count + (value > 0 ? 1 : 0), 0);
      }

			render() {
				if (!this.offscreenCanvas) {
					this.offscreenCanvas = new OffscreenCanvas(this.canvas.width, this.canvas.height);
					this.offscreenCtx = this.offscreenCanvas.getContext('2d', { 
						willReadFrequently: true 
					});
				}
				
				this.offscreenCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);
				const imageData = new ImageData(this.canvas.width, this.canvas.height);
				const data = imageData.data;
				
				const bytesPerCell = this.cellSize * 4;
				const bytesPerRow = this.canvas.width * 4;
				
				for (let y = 0; y < this.gridSizeY; y++) {
					const gridRowOffset = y * this.gridSizeX;
					const canvasRowOffset = y * this.cellSize * bytesPerRow;
					
					for (let x = 0; x < this.gridSizeX; x++) {
						const value1 = this.blurredGrid1[gridRowOffset + x];
						const value2 = this.blurredGrid2[gridRowOffset + x];
						
						if (value1 > 0 || value2 > 0) {
							const r = Math.min(value2 * 255, 255) | 0;
							const b = Math.min(value1 * 255, 255) | 0;
							const a = Math.min(Math.max(value1, value2) * 255, 255) | 0;
							
							for (let dy = 0; dy < this.cellSize; dy++) {
								const rowOffset = canvasRowOffset + dy * bytesPerRow + x * bytesPerCell;
								for (let dx = 0; dx < this.cellSize; dx++) {
									const pixelOffset = rowOffset + dx * 4;
									data[pixelOffset] = r;
									data[pixelOffset + 1] = 0;
									data[pixelOffset + 2] = b;
									data[pixelOffset + 3] = a;
								}
							}
						}
					}
				}
				
				this.offscreenCtx.putImageData(imageData, 0, 0);
				this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
				this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
				this.ctx.drawImage(this.offscreenCanvas, 0, 0);
			}
    }

    // Initialize the simulation
    const pixelSim = new PixelSimulation('particleCanvas', 150, 150);
    </script>
</body>
</html>