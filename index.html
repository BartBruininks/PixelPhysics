<!DOCTYPE html>
<!--
// Global pixel field automaton v0.1.4
// 
// CHANGES:
// * Normalization of random noise for step by step visualization
// * Attempt at improving UI (placed continous simulation controls under field)
//
// FEATURES:
// * Drawing/Erasing
// * Three fields
// * Step by step simulation for educational puppores and bug fixing
// * Continuous simulation
// * Seperable and iterative Gaussian blurring
// * Pixel perfect rendering
// * Custom field size
// * Performance monitoring
// * Periodic boundary conditions
// * Much better code quality
// * Interaction matrix for cross field interactions
// * Field locking
-->

<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three-Field Pixel Particle Simulation</title>
    <style>
        body { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            font-family: Arial, sans-serif;
            margin: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .main-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            width: 100%;
            padding: 20px;
        }
        
        .left-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .canvas-container {
            flex: 0 0 auto;
        }
        
        .controls-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 400px;
            max-width: 500px;
            height: 100%;
            max-height: calc(100vh - 120px); 
            overflow-y: auto; 
            padding-right: 10px; 
        }
        
        canvas { 
            border: 1px solid black;
        }
        
        .control-group {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .control-row label {
            min-width: 120px;
            font-size: 0.9rem;
        }
        
        .control-row input[type="range"] {
            flex: 1;
        }
        
        .control-row span {
            min-width: 40px;
            text-align: right;
        }
        
        .button-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        input[type="number"] {
            width: 80px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .step-count {
            font-size: 0.9rem;
            color: #666;
            margin-left: 10px;
        }

        .field-selector {
            display: flex;
            gap: 10px;
        }

        .field-button {
            flex: 1;
            padding: 8px;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .field-button.field1 {
            background: rgba(0, 0, 255, 0.5); /* Blue */
        }

        .field-button.field2 {
            background: rgba(255, 0, 0, 0.5); /* Red */
        }

        .field-button.field3 {
            background: rgba(0, 255, 0, 0.5); /* Green */
        }

        .field-button.selected {
            border-color: #007bff;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
        }

        .interaction-matrix {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .interaction-matrix input {
            width: 100%;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h2>Three-Field Pixel Particle Simulation</h2>
    <div class="main-container">
        <div class="left-section">
            <div class="canvas-container">
                <canvas id="particleCanvas" width="900" height="900"></canvas>
            </div>
        </div>

        <div class="controls-container">
            <div class="control-group">
                <h3>Continuous Simulation</h3>
                <div class="control-row">
                    <label>Steps:</label>
                    <input type="number" id="simulationSteps" min="1" max="10000" value="100000">
                    <span class="step-count">Current: <span id="currentStepDisplay">0</span></span>
                </div>
                <div class="button-group">
                    <button id="startSimulationButton">Start Simulation</button>
                    <button id="stopSimulationButton" disabled>Stop Simulation</button>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Field Selection</h3>
                <div class="field-selector">
                    <button class="field-button field1 selected" id="field1Button">Field 1 (Blue)</button>
                    <button class="field-button field2" id="field2Button">Field 2 (Red)</button>
                    <button class="field-button field3" id="field3Button">Field 3 (Green)</button>
                </div>
            </div>

            <div class="control-group">
                <h3>Drawing Controls</h3>
                <div class="control-row">
                    <label>Brush Size:</label>
                    <input type="range" id="brushSize" min="1" max="50" value="10">
                    <span id="brushSizeDisplay">10</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Simulation Parameters</h3>
                <div class="control-row">
                    <label>Sigma:</label>
                    <input type="range" id="sigmaSetting" min="0.1" max="10" step="0.1" value="1.5">
                    <span id="sigmaDisplay">1.5</span>
                </div>
                <div class="control-row">
                    <label>Temperature:</label>
                    <input type="range" id="temperatureSetting" min="0" max="5" step="0.02" value="0.50">
                    <span id="temperatureDisplay">0.5</span>
                </div>
                <div class="control-row">
                    <label>Gravity:</label>
                    <input type="range" id="gravitySetting" min="0" max="0.5" step="0.01" value="0">
                    <span id="gravityDisplay">0.00</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Interaction Matrix</h3>
                <div class="interaction-matrix">
                    <input type="number" id="interaction11" min="-5" max="5" step="0.1" value="1.0">
                    <input type="number" id="interaction12" min="-5" max="5" step="0.1" value="0.0">
                    <input type="number" id="interaction13" min="-5" max="5" step="0.1" value="0.0">
                    <input type="number" id="interaction21" min="-5" max="5" step="0.1" value="0.0">
                    <input type="number" id="interaction22" min="-5" max="5" step="0.1" value="1.0">
                    <input type="number" id="interaction23" min="-5" max="5" step="0.1" value="0.0">
                    <input type="number" id="interaction31" min="-5" max="5" step="0.1" value="0.0">
                    <input type="number" id="interaction32" min="-5" max="5" step="0.1" value="0.0">
                    <input type="number" id="interaction33" min="-5" max="5" step="0.1" value="1.0">
                </div>
            </div>

            <div class="control-group">
                <h3>Step Controls</h3>
                <div class="button-group">
                    <button id="blurButton">1. Apply Blur</button>
                    <button id="crossFieldButton">2. Cross Field Interactions</button>
                    <button id="rollDiceButton">3. Roll Dice</button>
                    <button id="discretizeButton">4. Discretize</button>
                    <button id="fullStepButton">Complete Step</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class Helper {
            static normalizeField(arr) {
                const max = Math.max(...arr);
                return arr.map(val => val / max);
            }

            static getBorderIndices(gridSizeX, gridSizeY) {
                const indices = [];

                // Top row
                for (let x = 0; x < gridSizeX; x++) {
                    indices.push(x);
                }

                // Bottom row
                let bottomRowStart = gridSizeX * (gridSizeY - 1);
                for (let x = 0; x < gridSizeX; x++) {
                    indices.push(bottomRowStart + x);
                }

                // Left and right edges (excluding corners)
                for (let y = 1; y < gridSizeY - 1; y++) {
                    // Left edge
                    indices.push(y * gridSizeX);
                    // Right edge
                    indices.push(y * gridSizeX + gridSizeX - 1);
                }

                return indices;
            }

            static createGaussianKernel1D(sigma, kernelSize) {
                const radius = Math.floor(kernelSize / 2);
                const kernel = new Float32Array(kernelSize);
                let sum = 0;

                // Create basic Gaussian distribution without gravity
                for (let x = -radius; x <= radius; x++) {
                    const value = Math.exp(-(x * x) / (2 * sigma * sigma));
                    kernel[x + radius] = value;
                    sum += value;
                }

                // Normalize
                for (let i = 0; i < kernelSize; i++) {
                    kernel[i] /= sum;
                }

                return kernel;
            }

            static applySeparableBlur(inputGrid, outputGrid, borderPixels, tempGrid, iterations, gridSizeX, gridSizeY, kernelSize, usePBC, gaussianKernel1D, gravity) {
                // Fully reset temporary grid
                tempGrid.fill(0);

                // Initial copy of input to output
                outputGrid.fill(0);

                // Perform blur iterations
                for (let iter = 0; iter < iterations; iter++) {
                    // Horizontal pass
                    this._horizontalPass(inputGrid, tempGrid, borderPixels, gridSizeX, gridSizeY, kernelSize, usePBC, gaussianKernel1D);

                    // Vertical pass
                    this._verticalPass(tempGrid, outputGrid, borderPixels, gridSizeX, gridSizeY, kernelSize, usePBC, gaussianKernel1D, gravity);
                }
            }

            static _horizontalPass(input, output, borderPixels, gridSizeX, gridSizeY, kernelSize, usePBC, gaussianKernel1D) {
                const radius = Math.floor(kernelSize / 2);
                output.fill(0);

                for (let y = 0; y < gridSizeY; y++) {
                    for (let x = 0; x < gridSizeX; x++) {
                        const index = y * gridSizeX + x;

                        let sum = 0;
                        let weightSum = 0;

                        for (let i = -radius; i <= radius; i++) {
                            let sourceX;
                            if (usePBC) {
                                sourceX = ((x + i) % gridSizeX + gridSizeX) % gridSizeX;
                            } else {
                                sourceX = Math.min(Math.max(x + i, 0), gridSizeX - 1);
                            }

                            const sourceIndex = y * gridSizeX + sourceX;
                            const weight = gaussianKernel1D[i + radius];

                            sum += input[sourceIndex] * weight;
                            weightSum += weight;
                        }

                        output[index] = sum / weightSum;
                    }
                }
            }

            static _verticalPass(input, output, borderPixels, gridSizeX, gridSizeY, kernelSize, usePBC, gaussianKernel1D, gravity) {
                const radius = Math.floor(kernelSize / 2);

                for (let x = 0; x < gridSizeX; x++) {
                    for (let y = 0; y < gridSizeY; y++) {
                        const index = y * gridSizeX + x;

                        let sum = 0;
                        let weightSum = 0;

                        for (let i = -radius; i <= radius; i++) {
                            let sourceY;
                            if (usePBC) {
                                sourceY = ((y + i) % gridSizeY + gridSizeY) % gridSizeY;
                            } else {
                                sourceY = Math.min(Math.max(y + i, 0), gridSizeY - 1);
                            }

                            const sourceIndex = sourceY * gridSizeX + x;
                            let weight = gaussianKernel1D[i + radius];

                            if (!usePBC) {
                                if (i > 0) {
                                    weight *= Math.pow(1 - gravity, i);
                                } else if (i < 0) {
                                    weight *= Math.pow(1 + gravity / 2, Math.abs(i));
                                }
                            }

                            sum += input[sourceIndex] * weight;
                            weightSum += weight;
                        }

                        output[index] = sum / weightSum;
                    }
                }
            }

            static rollDiceSingleField(grid, borderPixels, temperature) {
                for (let i = 0; i < grid.length; i++) {
                    if (!borderPixels.has(i)) {
                        const randomValue = Math.random();
                        grid[i] += (randomValue * temperature);
                    }
                }
            }

            static discretizeSingleField(grid, targetCount, borderPixels, boundaryGrid, usePBC, borderIndices) {
                // First restore boundary pixels to their original state if not PBC
                if (!usePBC) {
                    for (const index of borderIndices) {
                        grid[index] = boundaryGrid[index];
                    }
                }

                // Calculate how many non-boundary pixels we need
                const nonBorderPixelCount = targetCount - Array.from(borderPixels).reduce((sum, index) => sum + grid[index], 0);

                // Create arrays for sorting non-boundary pixels
                const values = [];
                const indices = [];

                for (let i = 0; i < grid.length; i++) {
                    if (!borderPixels.has(i)) {
                        values.push(grid[i]);
                        indices.push(i);
                    }
                }

                // Sort indices by their corresponding values
                indices.sort((a, b) => grid[b] - grid[a]);

                // Reset non-boundary pixels
                for (let i = 0; i < grid.length; i++) {
                    if (!borderPixels.has(i)) {
                        grid[i] = 0;
                    }
                }

                // Set top N non-boundary pixels to 1
                for (let i = 0; i < nonBorderPixelCount && i < indices.length; i++) {
                    grid[indices[i]] = 1;
                }
            }

            static getGridValue(x, y, grid, gridSizeX) {
                return grid[y * gridSizeX + x];
            }

            static setGridValue(x, y, value, grid, gridSizeX) {
                grid[y * gridSizeX + x] = value;
            }
        }

        class PerformanceMonitor {
            constructor() {
                this.metrics = {
                    borders: [],
                    blur: [],
                    crossfield: [],
                    dice: [],
                    discretize: [],
                    render: []
                };
                this.sampleCount = 0;
                this.maxSamples = 100;
            }

            addMetric(component, time) {
                this.metrics[component].push(time);
                if (this.metrics[component].length > this.maxSamples) {
                    this.metrics[component].shift();
                }
            }

            getAverages() {
                const averages = {};
                let total = 0;

                for (const [component, times] of Object.entries(this.metrics)) {
                    if (times.length === 0) continue;
                    const avg = times.reduce((a, b) => a + b, 0) / times.length;
                    averages[component] = avg;
                    total += avg;
                }

                const normalized = {};
                for (const [component, avg] of Object.entries(averages)) {
                    normalized[component] = (avg / total * 100).toFixed(1);
                }

                return {
                    raw: averages,
                    normalized,
                    total: total.toFixed(2)
                };
            }

            logPerformance() {
                const stats = this.getAverages();
                console.log('\n=== Performance Breakdown ===');
                console.log(`Total time per step: ${stats.total}ms`);
                console.log('Component breakdown:');
                Object.entries(stats.normalized).forEach(([component, percentage]) => {
                    const bar = 'â–ˆ'.repeat(Math.round(percentage / 2));
                    console.log(`${component.padEnd(10)}: ${percentage}% ${bar}`);
                });
                console.log('=========================\n');
            }
        }

        class PixelSimulation {
            constructor(canvasId, initialGridSizeX = 150, initialGridSizeY = 150) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.gridSizeX = initialGridSizeX;
                this.gridSizeY = initialGridSizeY;
                this.updateCanvasSize();

                // Initialize grids with correct dimensions
                this.initializeGrids();
                this.usePBC = false;
                this.borderIndices = Helper.getBorderIndices(this.gridSizeX, this.gridSizeY);

                // Rest of the constructor remains the same
                this.interactionMatrix = [
                    [1.0, 0.0, 0.0],
                    [0.0, 1.0, 0.0],
                    [0.0, 0.0, 1.0]
                ];
                this.gravity = 0.0;
                this.npixels1 = 0.0;
                this.npixels2 = 0.0;
                this.npixels3 = 0.0;
                this.temperature = 0.5;

                this.borderPixels1 = new Set();
                this.borderPixels2 = new Set();
                this.borderPixels3 = new Set();

                this.brushSize = 10;
                this.isDrawing = false;
                this.drawMode = null;
                this.activeField = 1;
                this.lockField1 = false; // Lock for blue field
                this.lockField2 = false; // Lock for red field
                this.lockField3 = false; // Lock for green field

                this.sigma = 1.5;
                this.kernelSize = 11;
                this.iterations = 1;
                this.gaussianKernel1D = Helper.createGaussianKernel1D(this.sigma, this.kernelSize);

                this.simulationTimer = null;
                this.currentStep = 0;
                this.totalSimulationSteps = 100000;

                this.setupEventListeners();
                this.setupControls();
                this.updateBorderPixels();

                this.performance = new PerformanceMonitor();
            }

            initializeGrids() {
                const size = this.gridSizeX * this.gridSizeY;
                this.grid1 = new Float32Array(size);
                this.grid2 = new Float32Array(size);
                this.grid3 = new Float32Array(size);
                this.blurredGrid1 = new Float32Array(size);
                this.blurredGrid2 = new Float32Array(size);
                this.blurredGrid3 = new Float32Array(size);
                this.boundaryGrid1 = new Float32Array(size);
                this.boundaryGrid2 = new Float32Array(size);
                this.boundaryGrid3 = new Float32Array(size);
                this.tempGrid = new Float32Array(size);
            }

            setupControls() {
                this.setupSizeControls();
                this.setupFieldSelection();
                this.setupBrushSizeControl();
                this.setupBlurControls();
                this.setupPBCControl();
                this.setupSimulationControls();
                this.setupStepControls();
                this.setupFieldLockControls();
                this.setupInteractionMatrixControls();
            }

            setupInteractionMatrixControls() {
                const interactionIds = ['interaction11', 'interaction12', 'interaction13',
                    'interaction21', 'interaction22', 'interaction23',
                    'interaction31', 'interaction32', 'interaction33'];

                interactionIds.forEach((id, index) => {
                    const input = document.getElementById(id);
                    input.addEventListener('input', (e) => {
                        const row = Math.floor(index / 3);
                        const col = index % 3;
                        this.interactionMatrix[row][col] = parseFloat(e.target.value);
                    });
                });
            }

            setupFieldLockControls() {
                const controlGroup = document.createElement('div');
                controlGroup.className = 'control-group';
                controlGroup.innerHTML = `
                    <h3>Field Locking</h3>
                    <div class="control-row">
                        <label>Lock Field 1 (Blue):</label>
                        <input type="checkbox" id="lockField1Toggle">
                    </div>
                    <div class="control-row">
                        <label>Lock Field 2 (Red):</label>
                        <input type="checkbox" id="lockField2Toggle">
                    </div>
                    <div class="control-row">
                        <label>Lock Field 3 (Green):</label>
                        <input type="checkbox" id="lockField3Toggle">
                    </div>
                `;

                // Insert after the field selection controls
                const fieldSelectionGroup = document.getElementById('field1Button').closest('.control-group');
                fieldSelectionGroup.parentNode.insertBefore(controlGroup, fieldSelectionGroup.nextSibling);

                // Add event listeners
                document.getElementById('lockField1Toggle').addEventListener('change', (e) => {
                    this.lockField1 = e.target.checked;
                    this.updateBorderPixels(); // Update border pixels when lock status changes
                });

                document.getElementById('lockField2Toggle').addEventListener('change', (e) => {
                    this.lockField2 = e.target.checked;
                    this.updateBorderPixels(); // Update border pixels when lock status changes
                });

                document.getElementById('lockField3Toggle').addEventListener('change', (e) => {
                    this.lockField3 = e.target.checked;
                    this.updateBorderPixels(); // Update border pixels when lock status changes
                });
            }

            setupSizeControls() {
                // Create new control group for size settings
                const controlGroup = document.createElement('div');
                controlGroup.className = 'control-group';
                controlGroup.innerHTML = `
                <h3>Grid Size Controls</h3>
                <div class="control-row">
                    <label>X Size:</label>
                    <input type="range" id="gridSizeX" min="50" max="300" value="${this.gridSizeX}">
                    <span id="gridSizeXDisplay">${this.gridSizeX}</span>
                </div>
                <div class="control-row">
                    <label>Y Size:</label>
                    <input type="range" id="gridSizeY" min="50" max="300" value="${this.gridSizeY}">
                    <span id="gridSizeYDisplay">${this.gridSizeY}</span>
                </div>
                <div class="control-row">
                    <button id="applyGridSize">Apply Size Changes</button>
                </div>
            `;

                // Insert at the beginning of controls container
                const controlsContainer = document.querySelector('.controls-container');
                controlsContainer.insertBefore(controlGroup, controlsContainer.firstChild);

                // Add event listeners
                const xSlider = document.getElementById('gridSizeX');
                const ySlider = document.getElementById('gridSizeY');
                const xDisplay = document.getElementById('gridSizeXDisplay');
                const yDisplay = document.getElementById('gridSizeYDisplay');
                const applyButton = document.getElementById('applyGridSize');

                xSlider.addEventListener('input', () => {
                    xDisplay.textContent = xSlider.value;
                });

                ySlider.addEventListener('input', () => {
                    yDisplay.textContent = ySlider.value;
                });

                applyButton.addEventListener('click', () => {
                    const newSizeX = parseInt(xSlider.value);
                    const newSizeY = parseInt(ySlider.value);

                    // Update grid sizes
                    this.gridSizeX = newSizeX;
                    this.gridSizeY = newSizeY;

                    // Reinitialize simulation with new sizes
                    this.updateCanvasSize();
                    this.initializeGrids();
                    this.borderIndices = Helper.getBorderIndices(this.gridSizeX, this.gridSizeY);
                    this.updateBorderPixels();

                    // Clear the canvas and render
                    this.render();
                });
            }

            setupPBCControl() {
                const controlGroup = document.createElement('div');
                controlGroup.className = 'control-group';
                controlGroup.innerHTML = `
                <h3>Boundary Conditions</h3>
                <div class="control-row">
                    <label>Periodic Boundary:</label>
                    <input type="checkbox" id="pbcToggle">
                </div>
            `;

                // Find the blur controls and insert after them
                const kernelSizeElement = document.getElementById('kernelSize');
                if (kernelSizeElement) {
                    const blurControls = kernelSizeElement.closest('.control-group');
                    blurControls.parentNode.insertBefore(controlGroup, blurControls.nextSibling);
                } else {
                    // Fallback: append to controls container if blur controls not found
                    const controlsContainer = document.querySelector('.controls-container');
                    controlsContainer.appendChild(controlGroup);
                }

                // Add event listener
                document.getElementById('pbcToggle').addEventListener('change', (e) => {
                    this.usePBC = e.target.checked;
                    if (this.usePBC) {
                        this.borderPixels1.clear();
                        this.borderPixels2.clear();
                        this.borderPixels3.clear();
                        this.boundaryGrid1.fill(0);
                        this.boundaryGrid2.fill(0);
                        this.boundaryGrid3.fill(0);
                    } else {
                        this.updateBorderPixels();
                    }
                });
            }

            setupBlurControls() {
                const controlGroup = document.createElement('div');
                controlGroup.className = 'control-group';
                controlGroup.innerHTML = `
                <h3>Blur Settings</h3>
                <div class="control-row">
                    <label>Kernel Size:</label>
                    <select id="kernelSize">
                        <option value="3">3x3</option>
                        <option value="5">5x5</option>
                        <option value="7">7x7</option>
                        <option value="9">9x9</option>
                        <option value="11" selected>11x11</option>
                        <option value="13">13x13</option>
                        <option value="15">15x15</option>
                        <option value="17">17x17</option>
                        <option value="19">19x19</option>
                    </select>
                </div>
                <div class="control-row">
                    <label>Iterations:</label>
                    <input type="range" id="iterationsSetting" min="1" max="10" value="1">
                    <span id="iterationsDisplay">1</span>
                </div>
            `;

                // Insert after sigma control
                const sigmaControl = document.getElementById('sigmaSetting').closest('.control-group');
                sigmaControl.parentNode.insertBefore(controlGroup, sigmaControl.nextSibling);

                // Add event listeners
                document.getElementById('kernelSize').addEventListener('change', (e) => {
                    this.kernelSize = parseInt(e.target.value);
                    this.gaussianKernel1D = Helper.createGaussianKernel1D(this.sigma, this.kernelSize);
                });

                const iterationsSlider = document.getElementById('iterationsSetting');
                const iterationsDisplay = document.getElementById('iterationsDisplay');
                iterationsSlider.addEventListener('input', (e) => {
                    this.iterations = parseInt(e.target.value);
                    iterationsDisplay.textContent = this.iterations;
                });
            }

            setupFieldSelection() {
                const field1Button = document.getElementById('field1Button');
                const field2Button = document.getElementById('field2Button');
                const field3Button = document.getElementById('field3Button');

                field1Button.addEventListener('click', () => {
                    this.activeField = 1;
                    field1Button.classList.add('selected');
                    field2Button.classList.remove('selected');
                    field3Button.classList.remove('selected');
                });

                field2Button.addEventListener('click', () => {
                    this.activeField = 2;
                    field1Button.classList.remove('selected');
                    field2Button.classList.add('selected');
                    field3Button.classList.remove('selected');
                });

                field3Button.addEventListener('click', () => {
                    this.activeField = 3;
                    field1Button.classList.remove('selected');
                    field2Button.classList.remove('selected');
                    field3Button.classList.add('selected');

                });
            }

            setupStepControls() {
                document.getElementById('blurButton').addEventListener('click', () => {
                    this.applyGaussianBlur();
                    this.render();
                });

                document.getElementById('crossFieldButton').addEventListener('click', () => {
                    this.applyCrossFieldInteractions();
                    this.render();
                });

                document.getElementById('rollDiceButton').addEventListener('click', () => {
                    this.rollDice();
                    Helper.normalizeField(this.blurredGrid1);
                    Helper.normalizeField(this.blurredGrid2);
                    this.render();
                });

                document.getElementById('discretizeButton').addEventListener('click', () => {
                    this.discretize();
                    this.render();
                });

                document.getElementById('fullStepButton').addEventListener('click', () => {
                    this.simulationStep();
                    this.currentStep++;
                    document.getElementById('currentStepDisplay').textContent = this.currentStep;
                });
            }

            setupBrushSizeControl() {
                const brushSizeSlider = document.getElementById('brushSize');
                const brushSizeDisplay = document.getElementById('brushSizeDisplay');

                brushSizeSlider.addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    brushSizeDisplay.textContent = this.brushSize;
                });
            }

            setupSimulationControls() {
                const sigmaSlider = document.getElementById('sigmaSetting');
                const sigmaDisplay = document.getElementById('sigmaDisplay');
                const simulationStepsInput = document.getElementById('simulationSteps');
                const startSimulationButton = document.getElementById('startSimulationButton');
                const stopSimulationButton = document.getElementById('stopSimulationButton');
                const currentStepDisplay = document.getElementById('currentStepDisplay');
                const temperatureSlider = document.getElementById('temperatureSetting');
                const temperatureDisplay = document.getElementById('temperatureDisplay');
                const gravitySlider = document.getElementById('gravitySetting');
                const gravityDisplay = document.getElementById('gravityDisplay');

                // Interaction matrix inputs
                const interactionIds = ['interaction11', 'interaction12', 'interaction13',
                    'interaction21', 'interaction22', 'interaction23',
                    'interaction31', 'interaction32', 'interaction33'];

                // Initialize interaction matrix values from the UI
                interactionIds.forEach((id, index) => {
                    const input = document.getElementById(id);
                    const row = Math.floor(index / 3);
                    const col = index % 3;
                    input.value = this.interactionMatrix[row][col]; // Set initial value from the matrix
                });

                // Event listeners for interaction matrix inputs
                interactionIds.forEach((id, index) => {
                    const input = document.getElementById(id);
                    input.addEventListener('input', (e) => {
                        const row = Math.floor(index / 3);
                        const col = index % 3;
                        this.interactionMatrix[row][col] = parseFloat(e.target.value);
                    });
                });

                // Sigma slider
                sigmaSlider.addEventListener('input', (e) => {
                    this.sigma = parseFloat(e.target.value);
                    sigmaDisplay.textContent = this.sigma.toFixed(1);
                    this.gaussianKernel1D = Helper.createGaussianKernel1D(this.sigma, this.kernelSize);
                });

                // Temperature slider
                temperatureSlider.addEventListener('input', (e) => {
                    this.temperature = parseFloat(e.target.value);
                    temperatureDisplay.textContent = this.temperature.toFixed(2);
                });

                // Gravity slider
                gravitySlider.addEventListener('input', (e) => {
                    this.gravity = parseFloat(e.target.value);
                    gravityDisplay.textContent = this.gravity.toFixed(2);
                });

                // Simulation steps input
                simulationStepsInput.addEventListener('input', (e) => {
                    this.totalSimulationSteps = parseInt(e.target.value);
                });

                // Start simulation button
                startSimulationButton.addEventListener('click', () => {
                    this.startSimulation();
                    this.updateSimulationButtons(true);
                });

                // Stop simulation button
                stopSimulationButton.addEventListener('click', () => {
                    this.stopSimulation();
                    this.updateSimulationButtons(false);
                });
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousedown', this.startDrawing.bind(this));
                this.canvas.addEventListener('mousemove', this.draw.bind(this));
                this.canvas.addEventListener('mouseup', this.stopDrawing.bind(this));
                this.canvas.addEventListener('mouseout', this.stopDrawing.bind(this));
            }

            updateCanvasSize() {
                // Calculate cell sizes to maintain aspect ratio
                const maxWidth = 900;  // Maximum canvas width
                const maxHeight = 900; // Maximum canvas height

                // Calculate the cell size that will fit within max dimensions
                const cellSizeX = Math.floor(maxWidth / this.gridSizeX);
                const cellSizeY = Math.floor(maxHeight / this.gridSizeY);

                // Use the smaller cell size to ensure square cells
                this.cellSize = Math.min(cellSizeX, cellSizeY);

                // Update canvas dimensions
                this.canvas.width = this.gridSizeX * this.cellSize;
                this.canvas.height = this.gridSizeY * this.cellSize;

                // Clear any existing offscreen canvas
                this.offscreenCanvas = null;
            }

            updateSimulationButtons(isRunning) {
                document.getElementById('startSimulationButton').disabled = isRunning;
                document.getElementById('stopSimulationButton').disabled = !isRunning;
                document.getElementById('blurButton').disabled = isRunning;
                document.getElementById('crossFieldButton').disabled = isRunning;
                document.getElementById('rollDiceButton').disabled = isRunning;
                document.getElementById('discretizeButton').disabled = isRunning;
                document.getElementById('fullStepButton').disabled = isRunning;
            }

            startDrawing(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const gridX = Math.floor(x / this.cellSize);
                const gridY = Math.floor(y / this.cellSize);

                const grid = this.activeField === 1 ? this.grid1 : this.activeField === 2 ? this.grid2 : this.grid3;
                const currentValue = Helper.getGridValue(gridX, gridY, grid, this.gridSizeX);
                this.drawMode = currentValue > 0 ? 'remove' : 'add';

                this.isDrawing = true;
                this.draw(e);
            }

            stopDrawing() {
                this.isDrawing = false;
                this.drawMode = null;
                this.setCountPixels();
                this.updateBorderPixels();
            }

            draw(e) {
                if (!this.isDrawing || this.drawMode === null) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const gridX = Math.floor(x / this.cellSize);
                const gridY = Math.floor(y / this.cellSize);

                const radius = this.brushSize / 2;
                let pixelsChanged = false;
                const grid = this.activeField === 1 ? this.grid1 : (this.activeField === 2 ? this.grid2 : this.grid3);
                const boundaryGrid = this.activeField === 1 ? this.boundaryGrid1 : (this.activeField === 2 ? this.boundaryGrid2 : this.boundaryGrid3);

                for (let dx = -Math.ceil(radius); dx <= Math.ceil(radius); dx++) {
                    for (let dy = -Math.ceil(radius); dy <= Math.ceil(radius); dy++) {
                        const checkX = gridX + dx;
                        const checkY = gridY + dy;

                        if (Math.sqrt(dx * dx + dy * dy) <= radius) {
                            if (checkX >= 0 && checkX < this.gridSizeX &&
                                checkY >= 0 && checkY < this.gridSizeY) {
                                const index = checkY * this.gridSizeX + checkX;
                                const currentValue = Helper.getGridValue(checkX, checkY, grid, this.gridSizeX);
                                const newValue = this.drawMode === 'add' ? 1 : 0;

                                if (currentValue !== newValue) {
                                    Helper.setGridValue(checkX, checkY, newValue, grid, this.gridSizeX);
                                    if (!this.usePBC && this.borderIndices.includes(index)) {
                                        boundaryGrid[index] = newValue;
                                    }
                                    pixelsChanged = true;
                                }
                            }
                        }
                    }
                }

                if (pixelsChanged) {
                    const blurredGrid = this.activeField === 1 ? this.blurredGrid1 : (this.activeField === 2 ? this.blurredGrid2 : this.blurredGrid3);
                    blurredGrid.set(grid);
                    this.render();
                }
            }

            startSimulation() {
                if (this.simulationTimer) return;

                // Reset the step count if it's at the max
                if (this.currentStep >= this.totalSimulationSteps) {
                    this.currentStep = 0;
                }

                this.simulationTimer = setInterval(() => {
                    if (this.currentStep >= this.totalSimulationSteps) {
                        this.stopSimulation();
                        this.updateSimulationButtons(false);
                        return;
                    }

                    this.simulationStep();
                    this.currentStep++;
                    document.getElementById('currentStepDisplay').textContent = this.currentStep;
                }, 10);
            }

            stopSimulation() {
                if (this.simulationTimer) {
                    clearInterval(this.simulationTimer);
                    this.simulationTimer = null;
                }
            }

            simulationStep() {
                const t0 = performance.now();
                this.updateBorderPixels();
                const t1 = performance.now();
                this.performance.addMetric('borders', t1 - t0);

                const t2 = performance.now();
                this.applyGaussianBlur();
                const t3 = performance.now();
                this.performance.addMetric('blur', t3 - t2);

                const t8 = performance.now();
                this.render();
                const t9 = performance.now();
                this.performance.addMetric('render', t9 - t8);

                const t10 = performance.now();
                this.applyCrossFieldInteractions();
                const t11 = performance.now();
                this.performance.addMetric('crossfield', t11 - t10);

                const t4 = performance.now();
                this.rollDice();
                const t5 = performance.now();
                this.performance.addMetric('dice', t5 - t4);

                const t6 = performance.now();
                this.discretize();
                const t7 = performance.now();
                this.performance.addMetric('discretize', t7 - t6);

                if (this.currentStep % 100 === 0) {
                    this.performance.logPerformance();
                }
            }

            applyGaussianBlur() {
                // Apply independent blur to each field
                if (this.npixels1 > 0) {
                    Helper.applySeparableBlur(
                        this.grid1, this.blurredGrid1, this.borderPixels1, 
                        this.tempGrid, this.iterations, this.gridSizeX, this.gridSizeY, this.kernelSize, this.usePBC, this.gaussianKernel1D, this.gravity);
                }
                if (this.npixels2 > 0) {
                    Helper.applySeparableBlur(
                        this.grid2, this.blurredGrid2, this.borderPixels2, 
                        this.tempGrid, this.iterations, this.gridSizeX, this.gridSizeY, this.kernelSize, this.usePBC, this.gaussianKernel1D, this.gravity);
                }
                if (this.npixels3 > 0) {
                    Helper.applySeparableBlur(
                        this.grid3, this.blurredGrid3, this.borderPixels3, 
                        this.tempGrid, this.iterations, this.gridSizeX, this.gridSizeY, this.kernelSize, this.usePBC, this.gaussianKernel1D, this.gravity);
                }
            }

            applyCrossFieldInteractions() {
                for (let i = 0; i < this.grid1.length; i++) {
                    // Store the raw values for calculating the interactions (making a copy)
                    var rawBlurredGrid1 = this.blurredGrid1[i];
                    var rawBlurredGrid2 = this.blurredGrid2[i];
                    var rawBlurredGrid3 = this.blurredGrid3[i];

                    // Apply self-interaction first
                    this.blurredGrid1[i] *= this.interactionMatrix[0][0]; // Field 1 self-interaction
                    this.blurredGrid2[i] *= this.interactionMatrix[1][1]; // Field 2 self-interaction
                    this.blurredGrid3[i] *= this.interactionMatrix[2][2]; // Field 3 self-interaction

                    if (!this.borderPixels1.has(i)) {
                        if (rawBlurredGrid2 >= 0.01) {
                            this.blurredGrid1[i] += (0.5 - rawBlurredGrid2) * this.interactionMatrix[0][1] * 2; /* Miscibility */
                            //this.blurredGrid1[i] += (0.5 - rawBlurredGrid2) * this.interactionMatrix[0][1]; /* Interface */
                        }
                        if (rawBlurredGrid3 >= 0.01) {
                            this.blurredGrid1[i] += (0.5 - rawBlurredGrid3) * this.interactionMatrix[0][2] * 2;
                            //this.blurredGrid1[i] += (0.5 - rawBlurredGrid3) * this.interactionMatrix[0][2];
                        }
                    }
                    if (!this.borderPixels2.has(i)) {
                        if (rawBlurredGrid1 >= 0.01) {
                            //this.blurredGrid2[i] += rawBlurredGrid1 * this.interactionMatrix[1][0];
                            this.blurredGrid2[i] += (0.5 - rawBlurredGrid1) * this.interactionMatrix[1][0] * 2;
                        }
                        if (rawBlurredGrid3 >= 0.01) {
                            //this.blurredGrid2[i] += rawBlurredGrid3 * this.interactionMatrix[1][2];
                            this.blurredGrid2[i] += (0.5 - rawBlurredGrid3) * this.interactionMatrix[1][2] * 2;
                        }
                    }
                    if (!this.borderPixels3.has(i)) {
                        if (rawBlurredGrid1 >= 0.01) {
                            //this.blurredGrid3[i] += rawBlurredGrid1 * this.interactionMatrix[2][0];
                            this.blurredGrid3[i] += (0.5 - rawBlurredGrid1) * this.interactionMatrix[2][0] * 2;
                        }
                        if (rawBlurredGrid2 >= 0.01) {
                            //this.blurredGrid3[i] += rawBlurredGrid2 * this.interactionMatrix[2][1];
                            this.blurredGrid3[i] += (0.5 - rawBlurredGrid2) * this.interactionMatrix[2][1] * 2;
                        }
                    }
                }
            }

            rollDice() {
                // Roll the dice on the discretized grid to prepare for discretization
                if ((!this.lockField1) && (this.npixels1 > 0)) {
                    Helper.rollDiceSingleField(this.blurredGrid1, this.borderPixels1, this.temperature);
                }
                if ((!this.lockField2) && (this.npixels2 > 0)) {
                    Helper.rollDiceSingleField(this.blurredGrid2, this.borderPixels2, this.temperature);
                }
                if ((!this.lockField3) && (this.npixels3 > 0)) {
                    Helper.rollDiceSingleField(this.blurredGrid3, this.borderPixels3, this.temperature);
                }
            }

            discretize() {
                // Apply the discretization in the smooth field
                if ((!this.lockField1) && (this.npixels1 > 0)) {
                    Helper.discretizeSingleField(this.blurredGrid1, this.npixels1, this.borderPixels1, this.boundaryGrid1, this.usePBC, this.borderIndices);
                    this.grid1.set(this.blurredGrid1); // Copy back from smoothing to discretized field
                }
                if ((!this.lockField2) && (this.npixels2 > 0)) {
                    Helper.discretizeSingleField(this.blurredGrid2, this.npixels2, this.borderPixels2, this.boundaryGrid2, this.usePBC, this.borderIndices);
                    this.grid2.set(this.blurredGrid2); // Copy back from smoothing to discretized field
                }
                if ((!this.lockField3) && (this.npixels3 > 0)) {
                    Helper.discretizeSingleField(this.blurredGrid3, this.npixels3, this.borderPixels3, this.boundaryGrid3, this.usePBC, this.borderIndices);
                    this.grid3.set(this.blurredGrid3); // Copy back from smoothing to discretized field
                }
            }

            updateBorderPixels() {
                // Clear the border pixel sets
                this.borderPixels1.clear();
                this.borderPixels2.clear();
                this.borderPixels3.clear();

                // Skip border pixel updates if using PBC and no fields are locked
                if (this.usePBC && !this.lockField1 && !this.lockField2 && !this.lockField3) {
                    return;
                }

                // Add boundary pixels
                if (!this.usePBC) {
                    for (const index of this.borderIndices) {
                        if (this.boundaryGrid1[index] > 0) {
                            this.borderPixels1.add(index);
                        }
                        if (this.boundaryGrid2[index] > 0) {
                            this.borderPixels2.add(index);
                        }
                        if (this.boundaryGrid3[index] > 0) {
                            this.borderPixels3.add(index);
                        }
                    }
                }

                // If field 1 is locked, add all non-zero pixels to the border set
                if (this.lockField1) {
                    for (let i = 0; i < this.grid1.length; i++) {
                        if (this.grid1[i] > 0) {
                            this.borderPixels1.add(i);
                        }
                    }
                }

                // If field 2 is locked, add all non-zero pixels to the border set
                if (this.lockField2) {
                    for (let i = 0; i < this.grid2.length; i++) {
                        if (this.grid2[i] > 0) {
                            this.borderPixels2.add(i);
                        }
                    }
                }

                // If field 3 is locked, add all non-zero pixels to the border set
                if (this.lockField3) {
                    for (let i = 0; i < this.grid3.length; i++) {
                        if (this.grid3[i] > 0) {
                            this.borderPixels3.add(i);
                        }
                    }
                }
            }

            setCountPixels() {
                this.npixels1 = this.grid1.reduce((count, value) => count + (value > 0 ? 1 : 0), 0);
                this.npixels2 = this.grid2.reduce((count, value) => count + (value > 0 ? 1 : 0), 0);
                this.npixels3 = this.grid3.reduce((count, value) => count + (value > 0 ? 1 : 0), 0);
            }

            render() {
                if (!this.offscreenCanvas) {
                    this.offscreenCanvas = new OffscreenCanvas(this.canvas.width, this.canvas.height);
                    this.offscreenCtx = this.offscreenCanvas.getContext('2d', {
                        willReadFrequently: true
                    });
                }

                this.offscreenCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const imageData = new ImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;

                const bytesPerCell = this.cellSize * 4;
                const bytesPerRow = this.canvas.width * 4;

                for (let y = 0; y < this.gridSizeY; y++) {
                    const gridRowOffset = y * this.gridSizeX;
                    const canvasRowOffset = y * this.cellSize * bytesPerRow;

                    for (let x = 0; x < this.gridSizeX; x++) {
                        const value1 = this.blurredGrid1[gridRowOffset + x];
                        const value2 = this.blurredGrid2[gridRowOffset + x];
                        const value3 = this.blurredGrid3[gridRowOffset + x];

                        if (value1 > 0 || value2 > 0 || value3 > 0) {
                            // Field 1 (Blue)
                            const b = Math.min(value1 * 255, 255) | 0;
                            // Field 2 (Red)
                            const r = Math.min(value2 * 255, 255) | 0;
                            // Field 3 (Green)
                            const g = Math.min(value3 * 255, 255) | 0;
                            // Alpha (transparency based on the maximum value)
                            const a = Math.min(Math.max(value1, value2, value3) * 255, 255) | 0;

                            for (let dy = 0; dy < this.cellSize; dy++) {
                                const rowOffset = canvasRowOffset + dy * bytesPerRow + x * bytesPerCell;
                                for (let dx = 0; dx < this.cellSize; dx++) {
                                    const pixelOffset = rowOffset + dx * 4;
                                    data[pixelOffset] = r;       // Red (Field 2)
                                    data[pixelOffset + 1] = g;    // Green (Field 3)
                                    data[pixelOffset + 2] = b;    // Blue (Field 1)
                                    data[pixelOffset + 3] = a;    // Alpha
                                }
                            }
                        }
                    }
                }

                this.offscreenCtx.putImageData(imageData, 0, 0);
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.drawImage(this.offscreenCanvas, 0, 0);
            }
        }

        // Initialize the simulation
        const pixelSim = new PixelSimulation('particleCanvas', 150, 150);
    </script>
</body>
</html>